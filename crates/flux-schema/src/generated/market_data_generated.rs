// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;


#[allow(unused_imports, dead_code)]
pub mod flux {

#[allow(unused_imports, dead_code)]
pub mod schema {


#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE_TYPE: i8 = 100;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_TYPE: [MessageType; 11] = [
  MessageType::NONE,
  MessageType::HEALTH_REQUEST,
  MessageType::HEALTH_RESPONSE,
  MessageType::GET_CURSOR_REQUEST,
  MessageType::GET_CURSOR_RESPONSE,
  MessageType::SUBSCRIBE_CANDLES_REQUEST,
  MessageType::SUBSCRIBE_CANDLES_ACK,
  MessageType::CANDLE_BATCH,
  MessageType::BACKFILL_CANDLES_REQUEST,
  MessageType::BACKFILL_CANDLES_RESPONSE,
  MessageType::ERROR_RESPONSE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MessageType(pub i8);
#[allow(non_upper_case_globals)]
impl MessageType {
  pub const NONE: Self = Self(0);
  pub const HEALTH_REQUEST: Self = Self(1);
  pub const HEALTH_RESPONSE: Self = Self(2);
  pub const GET_CURSOR_REQUEST: Self = Self(3);
  pub const GET_CURSOR_RESPONSE: Self = Self(4);
  pub const SUBSCRIBE_CANDLES_REQUEST: Self = Self(5);
  pub const SUBSCRIBE_CANDLES_ACK: Self = Self(6);
  pub const CANDLE_BATCH: Self = Self(7);
  pub const BACKFILL_CANDLES_REQUEST: Self = Self(8);
  pub const BACKFILL_CANDLES_RESPONSE: Self = Self(9);
  pub const ERROR_RESPONSE: Self = Self(100);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 100;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::HEALTH_REQUEST,
    Self::HEALTH_RESPONSE,
    Self::GET_CURSOR_REQUEST,
    Self::GET_CURSOR_RESPONSE,
    Self::SUBSCRIBE_CANDLES_REQUEST,
    Self::SUBSCRIBE_CANDLES_ACK,
    Self::CANDLE_BATCH,
    Self::BACKFILL_CANDLES_REQUEST,
    Self::BACKFILL_CANDLES_RESPONSE,
    Self::ERROR_RESPONSE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::HEALTH_REQUEST => Some("HEALTH_REQUEST"),
      Self::HEALTH_RESPONSE => Some("HEALTH_RESPONSE"),
      Self::GET_CURSOR_REQUEST => Some("GET_CURSOR_REQUEST"),
      Self::GET_CURSOR_RESPONSE => Some("GET_CURSOR_RESPONSE"),
      Self::SUBSCRIBE_CANDLES_REQUEST => Some("SUBSCRIBE_CANDLES_REQUEST"),
      Self::SUBSCRIBE_CANDLES_ACK => Some("SUBSCRIBE_CANDLES_ACK"),
      Self::CANDLE_BATCH => Some("CANDLE_BATCH"),
      Self::BACKFILL_CANDLES_REQUEST => Some("BACKFILL_CANDLES_REQUEST"),
      Self::BACKFILL_CANDLES_RESPONSE => Some("BACKFILL_CANDLES_RESPONSE"),
      Self::ERROR_RESPONSE => Some("ERROR_RESPONSE"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for MessageType {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for MessageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for MessageType {
    type Output = MessageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for MessageType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for MessageType {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    i8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for MessageType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE: [Message; 11] = [
  Message::NONE,
  Message::HealthRequest,
  Message::HealthResponse,
  Message::GetCursorRequest,
  Message::GetCursorResponse,
  Message::SubscribeCandlesRequest,
  Message::SubscribeCandlesAck,
  Message::CandleBatch,
  Message::BackfillCandlesRequest,
  Message::BackfillCandlesResponse,
  Message::ErrorResponse,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Message(pub u8);
#[allow(non_upper_case_globals)]
impl Message {
  pub const NONE: Self = Self(0);
  pub const HealthRequest: Self = Self(1);
  pub const HealthResponse: Self = Self(2);
  pub const GetCursorRequest: Self = Self(3);
  pub const GetCursorResponse: Self = Self(4);
  pub const SubscribeCandlesRequest: Self = Self(5);
  pub const SubscribeCandlesAck: Self = Self(6);
  pub const CandleBatch: Self = Self(7);
  pub const BackfillCandlesRequest: Self = Self(8);
  pub const BackfillCandlesResponse: Self = Self(9);
  pub const ErrorResponse: Self = Self(10);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::HealthRequest,
    Self::HealthResponse,
    Self::GetCursorRequest,
    Self::GetCursorResponse,
    Self::SubscribeCandlesRequest,
    Self::SubscribeCandlesAck,
    Self::CandleBatch,
    Self::BackfillCandlesRequest,
    Self::BackfillCandlesResponse,
    Self::ErrorResponse,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::HealthRequest => Some("HealthRequest"),
      Self::HealthResponse => Some("HealthResponse"),
      Self::GetCursorRequest => Some("GetCursorRequest"),
      Self::GetCursorResponse => Some("GetCursorResponse"),
      Self::SubscribeCandlesRequest => Some("SubscribeCandlesRequest"),
      Self::SubscribeCandlesAck => Some("SubscribeCandlesAck"),
      Self::CandleBatch => Some("CandleBatch"),
      Self::BackfillCandlesRequest => Some("BackfillCandlesRequest"),
      Self::BackfillCandlesResponse => Some("BackfillCandlesResponse"),
      Self::ErrorResponse => Some("ErrorResponse"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for Message {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for Message {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for Message {
    type Output = Message;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for Message {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for Message {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    u8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for Message {}
pub struct MessageUnionTableOffset {}

pub enum HealthRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HealthRequest<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for HealthRequest<'a> {
  type Inner = HealthRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> HealthRequest<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    HealthRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args HealthRequestArgs
  ) -> ::flatbuffers::WIPOffset<HealthRequest<'bldr>> {
    let mut builder = HealthRequestBuilder::new(_fbb);
    builder.finish()
  }

}

impl ::flatbuffers::Verifiable for HealthRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct HealthRequestArgs {
}
impl<'a> Default for HealthRequestArgs {
  #[inline]
  fn default() -> Self {
    HealthRequestArgs {
    }
  }
}

pub struct HealthRequestBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> HealthRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> HealthRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HealthRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<HealthRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for HealthRequest<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("HealthRequest");
      ds.finish()
  }
}
pub enum HealthResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HealthResponse<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for HealthResponse<'a> {
  type Inner = HealthResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> HealthResponse<'a> {
  pub const VT_OK: ::flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGE: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    HealthResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HealthResponseArgs<'args>
  ) -> ::flatbuffers::WIPOffset<HealthResponse<'bldr>> {
    let mut builder = HealthResponseBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    builder.add_ok(args.ok);
    builder.finish()
  }


  #[inline]
  pub fn ok(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(HealthResponse::VT_OK, Some(true)).unwrap()}
  }
  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(HealthResponse::VT_MESSAGE, None)}
  }
}

impl ::flatbuffers::Verifiable for HealthResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<bool>("ok", Self::VT_OK, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct HealthResponseArgs<'a> {
    pub ok: bool,
    pub message: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HealthResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    HealthResponseArgs {
      ok: true,
      message: None,
    }
  }
}

pub struct HealthResponseBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> HealthResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ok(&mut self, ok: bool) {
    self.fbb_.push_slot::<bool>(HealthResponse::VT_OK, ok, true);
  }
  #[inline]
  pub fn add_message(&mut self, message: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(HealthResponse::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> HealthResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HealthResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<HealthResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for HealthResponse<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("HealthResponse");
      ds.field("ok", &self.ok());
      ds.field("message", &self.message());
      ds.finish()
  }
}
pub enum StreamKeyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StreamKey<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for StreamKey<'a> {
  type Inner = StreamKey<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> StreamKey<'a> {
  pub const VT_SOURCE_ID: ::flatbuffers::VOffsetT = 4;
  pub const VT_SYMBOL: ::flatbuffers::VOffsetT = 6;
  pub const VT_INTERVAL: ::flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    StreamKey { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StreamKeyArgs<'args>
  ) -> ::flatbuffers::WIPOffset<StreamKey<'bldr>> {
    let mut builder = StreamKeyBuilder::new(_fbb);
    if let Some(x) = args.interval { builder.add_interval(x); }
    if let Some(x) = args.symbol { builder.add_symbol(x); }
    if let Some(x) = args.source_id { builder.add_source_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn source_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(StreamKey::VT_SOURCE_ID, None)}
  }
  #[inline]
  pub fn symbol(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(StreamKey::VT_SYMBOL, None)}
  }
  #[inline]
  pub fn interval(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(StreamKey::VT_INTERVAL, None)}
  }
}

impl ::flatbuffers::Verifiable for StreamKey<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("source_id", Self::VT_SOURCE_ID, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("symbol", Self::VT_SYMBOL, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("interval", Self::VT_INTERVAL, false)?
     .finish();
    Ok(())
  }
}
pub struct StreamKeyArgs<'a> {
    pub source_id: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub symbol: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub interval: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StreamKeyArgs<'a> {
  #[inline]
  fn default() -> Self {
    StreamKeyArgs {
      source_id: None,
      symbol: None,
      interval: None,
    }
  }
}

pub struct StreamKeyBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> StreamKeyBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_source_id(&mut self, source_id: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(StreamKey::VT_SOURCE_ID, source_id);
  }
  #[inline]
  pub fn add_symbol(&mut self, symbol: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(StreamKey::VT_SYMBOL, symbol);
  }
  #[inline]
  pub fn add_interval(&mut self, interval: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(StreamKey::VT_INTERVAL, interval);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> StreamKeyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StreamKeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<StreamKey<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for StreamKey<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("StreamKey");
      ds.field("source_id", &self.source_id());
      ds.field("symbol", &self.symbol());
      ds.field("interval", &self.interval());
      ds.finish()
  }
}
pub enum GetCursorRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetCursorRequest<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for GetCursorRequest<'a> {
  type Inner = GetCursorRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> GetCursorRequest<'a> {
  pub const VT_KEY: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    GetCursorRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetCursorRequestArgs<'args>
  ) -> ::flatbuffers::WIPOffset<GetCursorRequest<'bldr>> {
    let mut builder = GetCursorRequestBuilder::new(_fbb);
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<StreamKey<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<StreamKey>>(GetCursorRequest::VT_KEY, None)}
  }
}

impl ::flatbuffers::Verifiable for GetCursorRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<StreamKey>>("key", Self::VT_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct GetCursorRequestArgs<'a> {
    pub key: Option<::flatbuffers::WIPOffset<StreamKey<'a>>>,
}
impl<'a> Default for GetCursorRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetCursorRequestArgs {
      key: None,
    }
  }
}

pub struct GetCursorRequestBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> GetCursorRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<StreamKey<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<StreamKey>>(GetCursorRequest::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> GetCursorRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetCursorRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<GetCursorRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for GetCursorRequest<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("GetCursorRequest");
      ds.field("key", &self.key());
      ds.finish()
  }
}
pub enum CursorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Cursor<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Cursor<'a> {
  type Inner = Cursor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Cursor<'a> {
  pub const VT_LATEST_SEQUENCE: ::flatbuffers::VOffsetT = 4;
  pub const VT_LATEST_TS_MS: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Cursor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CursorArgs
  ) -> ::flatbuffers::WIPOffset<Cursor<'bldr>> {
    let mut builder = CursorBuilder::new(_fbb);
    builder.add_latest_ts_ms(args.latest_ts_ms);
    builder.add_latest_sequence(args.latest_sequence);
    builder.finish()
  }


  #[inline]
  pub fn latest_sequence(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Cursor::VT_LATEST_SEQUENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn latest_ts_ms(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Cursor::VT_LATEST_TS_MS, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Cursor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<u64>("latest_sequence", Self::VT_LATEST_SEQUENCE, false)?
     .visit_field::<i64>("latest_ts_ms", Self::VT_LATEST_TS_MS, false)?
     .finish();
    Ok(())
  }
}
pub struct CursorArgs {
    pub latest_sequence: u64,
    pub latest_ts_ms: i64,
}
impl<'a> Default for CursorArgs {
  #[inline]
  fn default() -> Self {
    CursorArgs {
      latest_sequence: 0,
      latest_ts_ms: 0,
    }
  }
}

pub struct CursorBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> CursorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_latest_sequence(&mut self, latest_sequence: u64) {
    self.fbb_.push_slot::<u64>(Cursor::VT_LATEST_SEQUENCE, latest_sequence, 0);
  }
  #[inline]
  pub fn add_latest_ts_ms(&mut self, latest_ts_ms: i64) {
    self.fbb_.push_slot::<i64>(Cursor::VT_LATEST_TS_MS, latest_ts_ms, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> CursorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CursorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Cursor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Cursor<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Cursor");
      ds.field("latest_sequence", &self.latest_sequence());
      ds.field("latest_ts_ms", &self.latest_ts_ms());
      ds.finish()
  }
}
pub enum GetCursorResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetCursorResponse<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for GetCursorResponse<'a> {
  type Inner = GetCursorResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> GetCursorResponse<'a> {
  pub const VT_KEY: ::flatbuffers::VOffsetT = 4;
  pub const VT_CURSOR: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    GetCursorResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetCursorResponseArgs<'args>
  ) -> ::flatbuffers::WIPOffset<GetCursorResponse<'bldr>> {
    let mut builder = GetCursorResponseBuilder::new(_fbb);
    if let Some(x) = args.cursor { builder.add_cursor(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<StreamKey<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<StreamKey>>(GetCursorResponse::VT_KEY, None)}
  }
  #[inline]
  pub fn cursor(&self) -> Option<Cursor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<Cursor>>(GetCursorResponse::VT_CURSOR, None)}
  }
}

impl ::flatbuffers::Verifiable for GetCursorResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<StreamKey>>("key", Self::VT_KEY, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<Cursor>>("cursor", Self::VT_CURSOR, false)?
     .finish();
    Ok(())
  }
}
pub struct GetCursorResponseArgs<'a> {
    pub key: Option<::flatbuffers::WIPOffset<StreamKey<'a>>>,
    pub cursor: Option<::flatbuffers::WIPOffset<Cursor<'a>>>,
}
impl<'a> Default for GetCursorResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetCursorResponseArgs {
      key: None,
      cursor: None,
    }
  }
}

pub struct GetCursorResponseBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> GetCursorResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<StreamKey<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<StreamKey>>(GetCursorResponse::VT_KEY, key);
  }
  #[inline]
  pub fn add_cursor(&mut self, cursor: ::flatbuffers::WIPOffset<Cursor<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<Cursor>>(GetCursorResponse::VT_CURSOR, cursor);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> GetCursorResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetCursorResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<GetCursorResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for GetCursorResponse<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("GetCursorResponse");
      ds.field("key", &self.key());
      ds.field("cursor", &self.cursor());
      ds.finish()
  }
}
pub enum SubscribeCandlesRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SubscribeCandlesRequest<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for SubscribeCandlesRequest<'a> {
  type Inner = SubscribeCandlesRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SubscribeCandlesRequest<'a> {
  pub const VT_KEY: ::flatbuffers::VOffsetT = 4;
  pub const VT_HAS_FROM_SEQUENCE: ::flatbuffers::VOffsetT = 6;
  pub const VT_FROM_SEQUENCE_EXCLUSIVE: ::flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    SubscribeCandlesRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SubscribeCandlesRequestArgs<'args>
  ) -> ::flatbuffers::WIPOffset<SubscribeCandlesRequest<'bldr>> {
    let mut builder = SubscribeCandlesRequestBuilder::new(_fbb);
    builder.add_from_sequence_exclusive(args.from_sequence_exclusive);
    if let Some(x) = args.key { builder.add_key(x); }
    builder.add_has_from_sequence(args.has_from_sequence);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<StreamKey<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<StreamKey>>(SubscribeCandlesRequest::VT_KEY, None)}
  }
  #[inline]
  pub fn has_from_sequence(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SubscribeCandlesRequest::VT_HAS_FROM_SEQUENCE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn from_sequence_exclusive(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SubscribeCandlesRequest::VT_FROM_SEQUENCE_EXCLUSIVE, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for SubscribeCandlesRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<StreamKey>>("key", Self::VT_KEY, false)?
     .visit_field::<bool>("has_from_sequence", Self::VT_HAS_FROM_SEQUENCE, false)?
     .visit_field::<u64>("from_sequence_exclusive", Self::VT_FROM_SEQUENCE_EXCLUSIVE, false)?
     .finish();
    Ok(())
  }
}
pub struct SubscribeCandlesRequestArgs<'a> {
    pub key: Option<::flatbuffers::WIPOffset<StreamKey<'a>>>,
    pub has_from_sequence: bool,
    pub from_sequence_exclusive: u64,
}
impl<'a> Default for SubscribeCandlesRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubscribeCandlesRequestArgs {
      key: None,
      has_from_sequence: false,
      from_sequence_exclusive: 0,
    }
  }
}

pub struct SubscribeCandlesRequestBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SubscribeCandlesRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<StreamKey<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<StreamKey>>(SubscribeCandlesRequest::VT_KEY, key);
  }
  #[inline]
  pub fn add_has_from_sequence(&mut self, has_from_sequence: bool) {
    self.fbb_.push_slot::<bool>(SubscribeCandlesRequest::VT_HAS_FROM_SEQUENCE, has_from_sequence, false);
  }
  #[inline]
  pub fn add_from_sequence_exclusive(&mut self, from_sequence_exclusive: u64) {
    self.fbb_.push_slot::<u64>(SubscribeCandlesRequest::VT_FROM_SEQUENCE_EXCLUSIVE, from_sequence_exclusive, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> SubscribeCandlesRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SubscribeCandlesRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<SubscribeCandlesRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for SubscribeCandlesRequest<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("SubscribeCandlesRequest");
      ds.field("key", &self.key());
      ds.field("has_from_sequence", &self.has_from_sequence());
      ds.field("from_sequence_exclusive", &self.from_sequence_exclusive());
      ds.finish()
  }
}
pub enum SubscribeCandlesAckOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SubscribeCandlesAck<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for SubscribeCandlesAck<'a> {
  type Inner = SubscribeCandlesAck<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SubscribeCandlesAck<'a> {
  pub const VT_ACCEPTED: ::flatbuffers::VOffsetT = 4;
  pub const VT_REASON: ::flatbuffers::VOffsetT = 6;
  pub const VT_KEY: ::flatbuffers::VOffsetT = 8;
  pub const VT_LATEST_SEQUENCE: ::flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    SubscribeCandlesAck { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SubscribeCandlesAckArgs<'args>
  ) -> ::flatbuffers::WIPOffset<SubscribeCandlesAck<'bldr>> {
    let mut builder = SubscribeCandlesAckBuilder::new(_fbb);
    builder.add_latest_sequence(args.latest_sequence);
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.reason { builder.add_reason(x); }
    builder.add_accepted(args.accepted);
    builder.finish()
  }


  #[inline]
  pub fn accepted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SubscribeCandlesAck::VT_ACCEPTED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn reason(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(SubscribeCandlesAck::VT_REASON, None)}
  }
  #[inline]
  pub fn key(&self) -> Option<StreamKey<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<StreamKey>>(SubscribeCandlesAck::VT_KEY, None)}
  }
  #[inline]
  pub fn latest_sequence(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SubscribeCandlesAck::VT_LATEST_SEQUENCE, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for SubscribeCandlesAck<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<bool>("accepted", Self::VT_ACCEPTED, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("reason", Self::VT_REASON, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<StreamKey>>("key", Self::VT_KEY, false)?
     .visit_field::<u64>("latest_sequence", Self::VT_LATEST_SEQUENCE, false)?
     .finish();
    Ok(())
  }
}
pub struct SubscribeCandlesAckArgs<'a> {
    pub accepted: bool,
    pub reason: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<::flatbuffers::WIPOffset<StreamKey<'a>>>,
    pub latest_sequence: u64,
}
impl<'a> Default for SubscribeCandlesAckArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubscribeCandlesAckArgs {
      accepted: false,
      reason: None,
      key: None,
      latest_sequence: 0,
    }
  }
}

pub struct SubscribeCandlesAckBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SubscribeCandlesAckBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_accepted(&mut self, accepted: bool) {
    self.fbb_.push_slot::<bool>(SubscribeCandlesAck::VT_ACCEPTED, accepted, false);
  }
  #[inline]
  pub fn add_reason(&mut self, reason: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(SubscribeCandlesAck::VT_REASON, reason);
  }
  #[inline]
  pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<StreamKey<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<StreamKey>>(SubscribeCandlesAck::VT_KEY, key);
  }
  #[inline]
  pub fn add_latest_sequence(&mut self, latest_sequence: u64) {
    self.fbb_.push_slot::<u64>(SubscribeCandlesAck::VT_LATEST_SEQUENCE, latest_sequence, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> SubscribeCandlesAckBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SubscribeCandlesAckBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<SubscribeCandlesAck<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for SubscribeCandlesAck<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("SubscribeCandlesAck");
      ds.field("accepted", &self.accepted());
      ds.field("reason", &self.reason());
      ds.field("key", &self.key());
      ds.field("latest_sequence", &self.latest_sequence());
      ds.finish()
  }
}
pub enum CandleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Candle<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Candle<'a> {
  type Inner = Candle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Candle<'a> {
  pub const VT_TS_MS: ::flatbuffers::VOffsetT = 4;
  pub const VT_OPEN: ::flatbuffers::VOffsetT = 6;
  pub const VT_HIGH: ::flatbuffers::VOffsetT = 8;
  pub const VT_LOW: ::flatbuffers::VOffsetT = 10;
  pub const VT_CLOSE: ::flatbuffers::VOffsetT = 12;
  pub const VT_VOLUME: ::flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Candle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CandleArgs
  ) -> ::flatbuffers::WIPOffset<Candle<'bldr>> {
    let mut builder = CandleBuilder::new(_fbb);
    builder.add_volume(args.volume);
    builder.add_close(args.close);
    builder.add_low(args.low);
    builder.add_high(args.high);
    builder.add_open(args.open);
    builder.add_ts_ms(args.ts_ms);
    builder.finish()
  }


  #[inline]
  pub fn ts_ms(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Candle::VT_TS_MS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn open(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Candle::VT_OPEN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn high(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Candle::VT_HIGH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn low(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Candle::VT_LOW, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn close(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Candle::VT_CLOSE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn volume(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Candle::VT_VOLUME, Some(0.0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Candle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i64>("ts_ms", Self::VT_TS_MS, false)?
     .visit_field::<f64>("open", Self::VT_OPEN, false)?
     .visit_field::<f64>("high", Self::VT_HIGH, false)?
     .visit_field::<f64>("low", Self::VT_LOW, false)?
     .visit_field::<f64>("close", Self::VT_CLOSE, false)?
     .visit_field::<f64>("volume", Self::VT_VOLUME, false)?
     .finish();
    Ok(())
  }
}
pub struct CandleArgs {
    pub ts_ms: i64,
    pub open: f64,
    pub high: f64,
    pub low: f64,
    pub close: f64,
    pub volume: f64,
}
impl<'a> Default for CandleArgs {
  #[inline]
  fn default() -> Self {
    CandleArgs {
      ts_ms: 0,
      open: 0.0,
      high: 0.0,
      low: 0.0,
      close: 0.0,
      volume: 0.0,
    }
  }
}

pub struct CandleBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> CandleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ts_ms(&mut self, ts_ms: i64) {
    self.fbb_.push_slot::<i64>(Candle::VT_TS_MS, ts_ms, 0);
  }
  #[inline]
  pub fn add_open(&mut self, open: f64) {
    self.fbb_.push_slot::<f64>(Candle::VT_OPEN, open, 0.0);
  }
  #[inline]
  pub fn add_high(&mut self, high: f64) {
    self.fbb_.push_slot::<f64>(Candle::VT_HIGH, high, 0.0);
  }
  #[inline]
  pub fn add_low(&mut self, low: f64) {
    self.fbb_.push_slot::<f64>(Candle::VT_LOW, low, 0.0);
  }
  #[inline]
  pub fn add_close(&mut self, close: f64) {
    self.fbb_.push_slot::<f64>(Candle::VT_CLOSE, close, 0.0);
  }
  #[inline]
  pub fn add_volume(&mut self, volume: f64) {
    self.fbb_.push_slot::<f64>(Candle::VT_VOLUME, volume, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> CandleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CandleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Candle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Candle<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Candle");
      ds.field("ts_ms", &self.ts_ms());
      ds.field("open", &self.open());
      ds.field("high", &self.high());
      ds.field("low", &self.low());
      ds.field("close", &self.close());
      ds.field("volume", &self.volume());
      ds.finish()
  }
}
pub enum CandleBatchOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CandleBatch<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for CandleBatch<'a> {
  type Inner = CandleBatch<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> CandleBatch<'a> {
  pub const VT_KEY: ::flatbuffers::VOffsetT = 4;
  pub const VT_START_SEQUENCE: ::flatbuffers::VOffsetT = 6;
  pub const VT_CANDLES: ::flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    CandleBatch { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CandleBatchArgs<'args>
  ) -> ::flatbuffers::WIPOffset<CandleBatch<'bldr>> {
    let mut builder = CandleBatchBuilder::new(_fbb);
    builder.add_start_sequence(args.start_sequence);
    if let Some(x) = args.candles { builder.add_candles(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<StreamKey<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<StreamKey>>(CandleBatch::VT_KEY, None)}
  }
  #[inline]
  pub fn start_sequence(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CandleBatch::VT_START_SEQUENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn candles(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Candle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Candle>>>>(CandleBatch::VT_CANDLES, None)}
  }
}

impl ::flatbuffers::Verifiable for CandleBatch<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<StreamKey>>("key", Self::VT_KEY, false)?
     .visit_field::<u64>("start_sequence", Self::VT_START_SEQUENCE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Candle>>>>("candles", Self::VT_CANDLES, false)?
     .finish();
    Ok(())
  }
}
pub struct CandleBatchArgs<'a> {
    pub key: Option<::flatbuffers::WIPOffset<StreamKey<'a>>>,
    pub start_sequence: u64,
    pub candles: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Candle<'a>>>>>,
}
impl<'a> Default for CandleBatchArgs<'a> {
  #[inline]
  fn default() -> Self {
    CandleBatchArgs {
      key: None,
      start_sequence: 0,
      candles: None,
    }
  }
}

pub struct CandleBatchBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> CandleBatchBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<StreamKey<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<StreamKey>>(CandleBatch::VT_KEY, key);
  }
  #[inline]
  pub fn add_start_sequence(&mut self, start_sequence: u64) {
    self.fbb_.push_slot::<u64>(CandleBatch::VT_START_SEQUENCE, start_sequence, 0);
  }
  #[inline]
  pub fn add_candles(&mut self, candles: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Candle<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(CandleBatch::VT_CANDLES, candles);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> CandleBatchBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CandleBatchBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<CandleBatch<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for CandleBatch<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("CandleBatch");
      ds.field("key", &self.key());
      ds.field("start_sequence", &self.start_sequence());
      ds.field("candles", &self.candles());
      ds.finish()
  }
}
pub enum BackfillCandlesRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BackfillCandlesRequest<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for BackfillCandlesRequest<'a> {
  type Inner = BackfillCandlesRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> BackfillCandlesRequest<'a> {
  pub const VT_KEY: ::flatbuffers::VOffsetT = 4;
  pub const VT_HAS_FROM_SEQUENCE: ::flatbuffers::VOffsetT = 6;
  pub const VT_FROM_SEQUENCE_EXCLUSIVE: ::flatbuffers::VOffsetT = 8;
  pub const VT_HAS_END_TS_MS: ::flatbuffers::VOffsetT = 10;
  pub const VT_END_TS_MS: ::flatbuffers::VOffsetT = 12;
  pub const VT_LIMIT: ::flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    BackfillCandlesRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BackfillCandlesRequestArgs<'args>
  ) -> ::flatbuffers::WIPOffset<BackfillCandlesRequest<'bldr>> {
    let mut builder = BackfillCandlesRequestBuilder::new(_fbb);
    builder.add_end_ts_ms(args.end_ts_ms);
    builder.add_from_sequence_exclusive(args.from_sequence_exclusive);
    builder.add_limit(args.limit);
    if let Some(x) = args.key { builder.add_key(x); }
    builder.add_has_end_ts_ms(args.has_end_ts_ms);
    builder.add_has_from_sequence(args.has_from_sequence);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<StreamKey<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<StreamKey>>(BackfillCandlesRequest::VT_KEY, None)}
  }
  #[inline]
  pub fn has_from_sequence(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BackfillCandlesRequest::VT_HAS_FROM_SEQUENCE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn from_sequence_exclusive(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BackfillCandlesRequest::VT_FROM_SEQUENCE_EXCLUSIVE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn has_end_ts_ms(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BackfillCandlesRequest::VT_HAS_END_TS_MS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn end_ts_ms(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(BackfillCandlesRequest::VT_END_TS_MS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn limit(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(BackfillCandlesRequest::VT_LIMIT, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for BackfillCandlesRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<StreamKey>>("key", Self::VT_KEY, false)?
     .visit_field::<bool>("has_from_sequence", Self::VT_HAS_FROM_SEQUENCE, false)?
     .visit_field::<u64>("from_sequence_exclusive", Self::VT_FROM_SEQUENCE_EXCLUSIVE, false)?
     .visit_field::<bool>("has_end_ts_ms", Self::VT_HAS_END_TS_MS, false)?
     .visit_field::<i64>("end_ts_ms", Self::VT_END_TS_MS, false)?
     .visit_field::<u32>("limit", Self::VT_LIMIT, false)?
     .finish();
    Ok(())
  }
}
pub struct BackfillCandlesRequestArgs<'a> {
    pub key: Option<::flatbuffers::WIPOffset<StreamKey<'a>>>,
    pub has_from_sequence: bool,
    pub from_sequence_exclusive: u64,
    pub has_end_ts_ms: bool,
    pub end_ts_ms: i64,
    pub limit: u32,
}
impl<'a> Default for BackfillCandlesRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    BackfillCandlesRequestArgs {
      key: None,
      has_from_sequence: false,
      from_sequence_exclusive: 0,
      has_end_ts_ms: false,
      end_ts_ms: 0,
      limit: 0,
    }
  }
}

pub struct BackfillCandlesRequestBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> BackfillCandlesRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<StreamKey<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<StreamKey>>(BackfillCandlesRequest::VT_KEY, key);
  }
  #[inline]
  pub fn add_has_from_sequence(&mut self, has_from_sequence: bool) {
    self.fbb_.push_slot::<bool>(BackfillCandlesRequest::VT_HAS_FROM_SEQUENCE, has_from_sequence, false);
  }
  #[inline]
  pub fn add_from_sequence_exclusive(&mut self, from_sequence_exclusive: u64) {
    self.fbb_.push_slot::<u64>(BackfillCandlesRequest::VT_FROM_SEQUENCE_EXCLUSIVE, from_sequence_exclusive, 0);
  }
  #[inline]
  pub fn add_has_end_ts_ms(&mut self, has_end_ts_ms: bool) {
    self.fbb_.push_slot::<bool>(BackfillCandlesRequest::VT_HAS_END_TS_MS, has_end_ts_ms, false);
  }
  #[inline]
  pub fn add_end_ts_ms(&mut self, end_ts_ms: i64) {
    self.fbb_.push_slot::<i64>(BackfillCandlesRequest::VT_END_TS_MS, end_ts_ms, 0);
  }
  #[inline]
  pub fn add_limit(&mut self, limit: u32) {
    self.fbb_.push_slot::<u32>(BackfillCandlesRequest::VT_LIMIT, limit, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> BackfillCandlesRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BackfillCandlesRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<BackfillCandlesRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for BackfillCandlesRequest<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("BackfillCandlesRequest");
      ds.field("key", &self.key());
      ds.field("has_from_sequence", &self.has_from_sequence());
      ds.field("from_sequence_exclusive", &self.from_sequence_exclusive());
      ds.field("has_end_ts_ms", &self.has_end_ts_ms());
      ds.field("end_ts_ms", &self.end_ts_ms());
      ds.field("limit", &self.limit());
      ds.finish()
  }
}
pub enum BackfillCandlesResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BackfillCandlesResponse<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for BackfillCandlesResponse<'a> {
  type Inner = BackfillCandlesResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> BackfillCandlesResponse<'a> {
  pub const VT_KEY: ::flatbuffers::VOffsetT = 4;
  pub const VT_START_SEQUENCE: ::flatbuffers::VOffsetT = 6;
  pub const VT_CANDLES: ::flatbuffers::VOffsetT = 8;
  pub const VT_HAS_MORE: ::flatbuffers::VOffsetT = 10;
  pub const VT_NEXT_SEQUENCE: ::flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    BackfillCandlesResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BackfillCandlesResponseArgs<'args>
  ) -> ::flatbuffers::WIPOffset<BackfillCandlesResponse<'bldr>> {
    let mut builder = BackfillCandlesResponseBuilder::new(_fbb);
    builder.add_next_sequence(args.next_sequence);
    builder.add_start_sequence(args.start_sequence);
    if let Some(x) = args.candles { builder.add_candles(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.add_has_more(args.has_more);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<StreamKey<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<StreamKey>>(BackfillCandlesResponse::VT_KEY, None)}
  }
  #[inline]
  pub fn start_sequence(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BackfillCandlesResponse::VT_START_SEQUENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn candles(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Candle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Candle>>>>(BackfillCandlesResponse::VT_CANDLES, None)}
  }
  #[inline]
  pub fn has_more(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BackfillCandlesResponse::VT_HAS_MORE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn next_sequence(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BackfillCandlesResponse::VT_NEXT_SEQUENCE, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for BackfillCandlesResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<StreamKey>>("key", Self::VT_KEY, false)?
     .visit_field::<u64>("start_sequence", Self::VT_START_SEQUENCE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Candle>>>>("candles", Self::VT_CANDLES, false)?
     .visit_field::<bool>("has_more", Self::VT_HAS_MORE, false)?
     .visit_field::<u64>("next_sequence", Self::VT_NEXT_SEQUENCE, false)?
     .finish();
    Ok(())
  }
}
pub struct BackfillCandlesResponseArgs<'a> {
    pub key: Option<::flatbuffers::WIPOffset<StreamKey<'a>>>,
    pub start_sequence: u64,
    pub candles: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Candle<'a>>>>>,
    pub has_more: bool,
    pub next_sequence: u64,
}
impl<'a> Default for BackfillCandlesResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    BackfillCandlesResponseArgs {
      key: None,
      start_sequence: 0,
      candles: None,
      has_more: false,
      next_sequence: 0,
    }
  }
}

pub struct BackfillCandlesResponseBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> BackfillCandlesResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<StreamKey<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<StreamKey>>(BackfillCandlesResponse::VT_KEY, key);
  }
  #[inline]
  pub fn add_start_sequence(&mut self, start_sequence: u64) {
    self.fbb_.push_slot::<u64>(BackfillCandlesResponse::VT_START_SEQUENCE, start_sequence, 0);
  }
  #[inline]
  pub fn add_candles(&mut self, candles: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Candle<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(BackfillCandlesResponse::VT_CANDLES, candles);
  }
  #[inline]
  pub fn add_has_more(&mut self, has_more: bool) {
    self.fbb_.push_slot::<bool>(BackfillCandlesResponse::VT_HAS_MORE, has_more, false);
  }
  #[inline]
  pub fn add_next_sequence(&mut self, next_sequence: u64) {
    self.fbb_.push_slot::<u64>(BackfillCandlesResponse::VT_NEXT_SEQUENCE, next_sequence, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> BackfillCandlesResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BackfillCandlesResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<BackfillCandlesResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for BackfillCandlesResponse<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("BackfillCandlesResponse");
      ds.field("key", &self.key());
      ds.field("start_sequence", &self.start_sequence());
      ds.field("candles", &self.candles());
      ds.field("has_more", &self.has_more());
      ds.field("next_sequence", &self.next_sequence());
      ds.finish()
  }
}
pub enum ErrorResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ErrorResponse<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for ErrorResponse<'a> {
  type Inner = ErrorResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ErrorResponse<'a> {
  pub const VT_CODE: ::flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGE: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    ErrorResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ErrorResponseArgs<'args>
  ) -> ::flatbuffers::WIPOffset<ErrorResponse<'bldr>> {
    let mut builder = ErrorResponseBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    builder.add_code(args.code);
    builder.finish()
  }


  #[inline]
  pub fn code(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ErrorResponse::VT_CODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(ErrorResponse::VT_MESSAGE, None)}
  }
}

impl ::flatbuffers::Verifiable for ErrorResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<u32>("code", Self::VT_CODE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct ErrorResponseArgs<'a> {
    pub code: u32,
    pub message: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ErrorResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    ErrorResponseArgs {
      code: 0,
      message: None,
    }
  }
}

pub struct ErrorResponseBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ErrorResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_code(&mut self, code: u32) {
    self.fbb_.push_slot::<u32>(ErrorResponse::VT_CODE, code, 0);
  }
  #[inline]
  pub fn add_message(&mut self, message: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(ErrorResponse::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ErrorResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ErrorResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<ErrorResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for ErrorResponse<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("ErrorResponse");
      ds.field("code", &self.code());
      ds.field("message", &self.message());
      ds.finish()
  }
}
pub enum EnvelopeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Envelope<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Envelope<'a> {
  type Inner = Envelope<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Envelope<'a> {
  pub const VT_SCHEMA_VERSION: ::flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_HINT: ::flatbuffers::VOffsetT = 6;
  pub const VT_CORRELATION_ID: ::flatbuffers::VOffsetT = 8;
  pub const VT_MESSAGE_TYPE: ::flatbuffers::VOffsetT = 10;
  pub const VT_MESSAGE: ::flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Envelope { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EnvelopeArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Envelope<'bldr>> {
    let mut builder = EnvelopeBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    if let Some(x) = args.correlation_id { builder.add_correlation_id(x); }
    builder.add_schema_version(args.schema_version);
    builder.add_message_type(args.message_type);
    builder.add_type_hint(args.type_hint);
    builder.finish()
  }


  #[inline]
  pub fn schema_version(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Envelope::VT_SCHEMA_VERSION, Some(1)).unwrap()}
  }
  #[inline]
  pub fn type_hint(&self) -> MessageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MessageType>(Envelope::VT_TYPE_HINT, Some(MessageType::NONE)).unwrap()}
  }
  #[inline]
  pub fn correlation_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Envelope::VT_CORRELATION_ID, None)}
  }
  #[inline]
  pub fn message_type(&self) -> Message {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Message>(Envelope::VT_MESSAGE_TYPE, Some(Message::NONE)).unwrap()}
  }
  #[inline]
  pub fn message(&self) -> Option<::flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Table<'a>>>(Envelope::VT_MESSAGE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_health_request(&self) -> Option<HealthRequest<'a>> {
    if self.message_type() == Message::HealthRequest {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HealthRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_health_response(&self) -> Option<HealthResponse<'a>> {
    if self.message_type() == Message::HealthResponse {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HealthResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_get_cursor_request(&self) -> Option<GetCursorRequest<'a>> {
    if self.message_type() == Message::GetCursorRequest {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GetCursorRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_get_cursor_response(&self) -> Option<GetCursorResponse<'a>> {
    if self.message_type() == Message::GetCursorResponse {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GetCursorResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_subscribe_candles_request(&self) -> Option<SubscribeCandlesRequest<'a>> {
    if self.message_type() == Message::SubscribeCandlesRequest {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SubscribeCandlesRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_subscribe_candles_ack(&self) -> Option<SubscribeCandlesAck<'a>> {
    if self.message_type() == Message::SubscribeCandlesAck {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SubscribeCandlesAck::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_candle_batch(&self) -> Option<CandleBatch<'a>> {
    if self.message_type() == Message::CandleBatch {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CandleBatch::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_backfill_candles_request(&self) -> Option<BackfillCandlesRequest<'a>> {
    if self.message_type() == Message::BackfillCandlesRequest {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BackfillCandlesRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_backfill_candles_response(&self) -> Option<BackfillCandlesResponse<'a>> {
    if self.message_type() == Message::BackfillCandlesResponse {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BackfillCandlesResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_error_response(&self) -> Option<ErrorResponse<'a>> {
    if self.message_type() == Message::ErrorResponse {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ErrorResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl ::flatbuffers::Verifiable for Envelope<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<u32>("schema_version", Self::VT_SCHEMA_VERSION, false)?
     .visit_field::<MessageType>("type_hint", Self::VT_TYPE_HINT, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("correlation_id", Self::VT_CORRELATION_ID, false)?
     .visit_union::<Message, _>("message_type", Self::VT_MESSAGE_TYPE, "message", Self::VT_MESSAGE, false, |key, v, pos| {
        match key {
          Message::HealthRequest => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<HealthRequest>>("Message::HealthRequest", pos),
          Message::HealthResponse => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<HealthResponse>>("Message::HealthResponse", pos),
          Message::GetCursorRequest => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<GetCursorRequest>>("Message::GetCursorRequest", pos),
          Message::GetCursorResponse => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<GetCursorResponse>>("Message::GetCursorResponse", pos),
          Message::SubscribeCandlesRequest => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<SubscribeCandlesRequest>>("Message::SubscribeCandlesRequest", pos),
          Message::SubscribeCandlesAck => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<SubscribeCandlesAck>>("Message::SubscribeCandlesAck", pos),
          Message::CandleBatch => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<CandleBatch>>("Message::CandleBatch", pos),
          Message::BackfillCandlesRequest => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<BackfillCandlesRequest>>("Message::BackfillCandlesRequest", pos),
          Message::BackfillCandlesResponse => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<BackfillCandlesResponse>>("Message::BackfillCandlesResponse", pos),
          Message::ErrorResponse => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<ErrorResponse>>("Message::ErrorResponse", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct EnvelopeArgs<'a> {
    pub schema_version: u32,
    pub type_hint: MessageType,
    pub correlation_id: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub message_type: Message,
    pub message: Option<::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for EnvelopeArgs<'a> {
  #[inline]
  fn default() -> Self {
    EnvelopeArgs {
      schema_version: 1,
      type_hint: MessageType::NONE,
      correlation_id: None,
      message_type: Message::NONE,
      message: None,
    }
  }
}

pub struct EnvelopeBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> EnvelopeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_schema_version(&mut self, schema_version: u32) {
    self.fbb_.push_slot::<u32>(Envelope::VT_SCHEMA_VERSION, schema_version, 1);
  }
  #[inline]
  pub fn add_type_hint(&mut self, type_hint: MessageType) {
    self.fbb_.push_slot::<MessageType>(Envelope::VT_TYPE_HINT, type_hint, MessageType::NONE);
  }
  #[inline]
  pub fn add_correlation_id(&mut self, correlation_id: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Envelope::VT_CORRELATION_ID, correlation_id);
  }
  #[inline]
  pub fn add_message_type(&mut self, message_type: Message) {
    self.fbb_.push_slot::<Message>(Envelope::VT_MESSAGE_TYPE, message_type, Message::NONE);
  }
  #[inline]
  pub fn add_message(&mut self, message: ::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Envelope::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> EnvelopeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EnvelopeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Envelope<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Envelope<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Envelope");
      ds.field("schema_version", &self.schema_version());
      ds.field("type_hint", &self.type_hint());
      ds.field("correlation_id", &self.correlation_id());
      ds.field("message_type", &self.message_type());
      match self.message_type() {
        Message::HealthRequest => {
          if let Some(x) = self.message_as_health_request() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::HealthResponse => {
          if let Some(x) = self.message_as_health_response() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::GetCursorRequest => {
          if let Some(x) = self.message_as_get_cursor_request() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::GetCursorResponse => {
          if let Some(x) = self.message_as_get_cursor_response() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::SubscribeCandlesRequest => {
          if let Some(x) = self.message_as_subscribe_candles_request() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::SubscribeCandlesAck => {
          if let Some(x) = self.message_as_subscribe_candles_ack() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::CandleBatch => {
          if let Some(x) = self.message_as_candle_batch() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::BackfillCandlesRequest => {
          if let Some(x) = self.message_as_backfill_candles_request() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::BackfillCandlesResponse => {
          if let Some(x) = self.message_as_backfill_candles_response() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::ErrorResponse => {
          if let Some(x) = self.message_as_error_response() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("message", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Envelope`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_envelope_unchecked`.
pub fn root_as_envelope(buf: &[u8]) -> Result<Envelope<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root::<Envelope>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Envelope` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_envelope_unchecked`.
pub fn size_prefixed_root_as_envelope(buf: &[u8]) -> Result<Envelope<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root::<Envelope>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Envelope` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_envelope_unchecked`.
pub fn root_as_envelope_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Envelope<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root_with_opts::<Envelope<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Envelope` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_envelope_unchecked`.
pub fn size_prefixed_root_as_envelope_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Envelope<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root_with_opts::<Envelope<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Envelope and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Envelope`.
pub unsafe fn root_as_envelope_unchecked(buf: &[u8]) -> Envelope<'_> {
  unsafe { ::flatbuffers::root_unchecked::<Envelope>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Envelope and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Envelope`.
pub unsafe fn size_prefixed_root_as_envelope_unchecked(buf: &[u8]) -> Envelope<'_> {
  unsafe { ::flatbuffers::size_prefixed_root_unchecked::<Envelope>(buf) }
}
#[inline]
pub fn finish_envelope_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(
    fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
    root: ::flatbuffers::WIPOffset<Envelope<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_envelope_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>, root: ::flatbuffers::WIPOffset<Envelope<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod schema
}  // pub mod flux

